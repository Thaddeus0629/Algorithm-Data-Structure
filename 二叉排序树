#include<iostream>
using namespace std;

typedef struct node
{
	int key;
	int data;
	struct node* lchild, * rchild;
}BSTNode, * BSTree;

/*1.查找*/
BSTNode* BSTsearch(BSTree& bt, int k)
{
	if (bt == NULL || bt->key == k) return bt;
	else if (k < bt->key)
		return BSTsearch(bt->lchild, k);
	else return BSTsearch(bt->rchild, k);
}

/*2.递归插入*/
void BSTInsert1(BSTree& bt, int k)
{
	if (bt == NULL)
	{
		BSTNode* t = new BSTNode;
		t->key = k;
		t->lchild = t->rchild = NULL;
		bt = t;
	}
	else if (k == bt->key) return;
	else if (k < bt->key) BSTInsert1(bt->lchild);
	else BSTInsert1(bt->rchild,k);

}

/*3.非递归插入*/
int BSTInsert2(BSTree& bt, int k)
{
	/*思想：定义一个父节点fa，然后循环找到插入点p，fa是插入点的
		    双亲节点，然后将p插入到对应为止，并连接上父节点*/
	BSTNode* fa, * p = bt;
	while (p != NULL)
	{
		if (p->key == k)return;
		fa = p;
		if (k < p->key)
			p = p->lchild;
		else
			p = p->rchild;
	}

	p = new BSTNode;
	p->key = k;
	p->lchild = p->rchild = NULL;
	if (bt == NULL) 
		bt = p;
	else if (k < fa->key) 
		fa->lchild = p;
	else 
		fa->rchild = p;
	return 1;
}


int main()
{

	system("pause");
	return 0;
}
